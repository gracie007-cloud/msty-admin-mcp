"""
Msty Admin MCP - Continuous Background Agents (Phase 28)

Long-running agents that monitor and act automatically.
- Code Sentinel: Watches git commits, runs security/quality checks
- Doc Keeper: Monitors code changes, flags outdated documentation
- Research Watcher: Tracks topics, summarizes new developments
- Meeting Prep: Analyzes calendar, pre-researches attendees

Features:
- Persistent background monitoring
- Event-triggered actions
- Scheduled tasks
- Alert generation
"""

import json
import logging
import threading
import time
import uuid
import os
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, Any, List, Optional, Callable
from dataclasses import dataclass, field
from enum import Enum

from .paths import get_msty_paths
from .agent_swarm import create_agent, execute_agent_task, AgentRole

logger = logging.getLogger("msty-admin-mcp")


class BackgroundAgentType(Enum):
    """Types of background agents."""
    CODE_SENTINEL = "code_sentinel"
    DOC_KEEPER = "doc_keeper"
    RESEARCH_WATCHER = "research_watcher"
    MEETING_PREP = "meeting_prep"
    CUSTOM = "custom"


class AlertSeverity(Enum):
    """Alert severity levels."""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


@dataclass
class BackgroundAgent:
    """A persistent background monitoring agent."""
    id: str
    agent_type: BackgroundAgentType
    name: str
    description: str
    interval_seconds: int
    enabled: bool
    created_at: str
    last_run: Optional[str] = None
    next_run: Optional[str] = None
    run_count: int = 0
    error_count: int = 0
    config: Dict[str, Any] = field(default_factory=dict)
    underlying_agent_id: Optional[str] = None


@dataclass
class Alert:
    """An alert generated by a background agent."""
    id: str
    agent_id: str
    agent_type: str
    severity: AlertSeverity
    title: str
    message: str
    created_at: str
    acknowledged: bool = False
    metadata: Dict[str, Any] = field(default_factory=dict)


# Storage
_background_agents: Dict[str, BackgroundAgent] = {}
_alerts: List[Alert] = []
_agent_threads: Dict[str, threading.Thread] = {}
_stop_flags: Dict[str, threading.Event] = {}


# Default configurations for agent types
DEFAULT_CONFIGS = {
    BackgroundAgentType.CODE_SENTINEL: {
        "watch_paths": ["."],
        "check_security": True,
        "check_quality": True,
        "check_tests": True,
        "ignore_patterns": ["*.pyc", "__pycache__", ".git", "node_modules"]
    },
    BackgroundAgentType.DOC_KEEPER: {
        "doc_paths": ["docs/", "README.md", "*.md"],
        "code_paths": ["src/", "lib/"],
        "staleness_days": 30
    },
    BackgroundAgentType.RESEARCH_WATCHER: {
        "topics": [],
        "sources": ["web"],
        "summary_frequency": "daily"
    },
    BackgroundAgentType.MEETING_PREP: {
        "calendar_source": "manual",
        "prep_hours_before": 2,
        "research_depth": "medium"
    }
}


def create_background_agent(
    agent_type: BackgroundAgentType,
    name: Optional[str] = None,
    interval_minutes: int = 60,
    config: Optional[Dict[str, Any]] = None,
    auto_start: bool = False
) -> Dict[str, Any]:
    """
    Create a new background monitoring agent.

    Args:
        agent_type: Type of background agent
        name: Custom name for the agent
        interval_minutes: How often to run (in minutes)
        config: Custom configuration overrides
        auto_start: Start monitoring immediately
    """
    agent_id = f"bg_{agent_type.value}_{uuid.uuid4().hex[:8]}"
    timestamp = datetime.now().isoformat()

    # Merge default config with custom config
    default_config = DEFAULT_CONFIGS.get(agent_type, {})
    merged_config = {**default_config, **(config or {})}

    # Create the underlying AI agent
    role_mapping = {
        BackgroundAgentType.CODE_SENTINEL: AgentRole.CODE,
        BackgroundAgentType.DOC_KEEPER: AgentRole.WRITING,
        BackgroundAgentType.RESEARCH_WATCHER: AgentRole.RESEARCH,
        BackgroundAgentType.MEETING_PREP: AgentRole.ANALYSIS,
        BackgroundAgentType.CUSTOM: AgentRole.GENERAL
    }

    underlying = create_agent(role_mapping.get(agent_type, AgentRole.GENERAL))

    agent = BackgroundAgent(
        id=agent_id,
        agent_type=agent_type,
        name=name or f"{agent_type.value.replace('_', ' ').title()}",
        description=_get_agent_description(agent_type),
        interval_seconds=interval_minutes * 60,
        enabled=auto_start,
        created_at=timestamp,
        config=merged_config,
        underlying_agent_id=underlying.get("agent_id")
    )

    _background_agents[agent_id] = agent

    if auto_start:
        start_background_agent(agent_id)

    return {
        "timestamp": timestamp,
        "agent_id": agent_id,
        "agent_type": agent_type.value,
        "name": agent.name,
        "interval_minutes": interval_minutes,
        "config": merged_config,
        "enabled": agent.enabled,
        "created": True
    }


def _get_agent_description(agent_type: BackgroundAgentType) -> str:
    """Get description for agent type."""
    descriptions = {
        BackgroundAgentType.CODE_SENTINEL: "Monitors code changes for security issues, quality problems, and test coverage",
        BackgroundAgentType.DOC_KEEPER: "Watches for code changes and identifies outdated documentation",
        BackgroundAgentType.RESEARCH_WATCHER: "Tracks specified topics and summarizes new developments",
        BackgroundAgentType.MEETING_PREP: "Prepares research and context before scheduled meetings",
        BackgroundAgentType.CUSTOM: "Custom background monitoring agent"
    }
    return descriptions.get(agent_type, "Background monitoring agent")


def start_background_agent(agent_id: str) -> Dict[str, Any]:
    """Start a background agent's monitoring loop."""
    if agent_id not in _background_agents:
        return {"error": f"Agent {agent_id} not found"}

    agent = _background_agents[agent_id]

    if agent_id in _agent_threads and _agent_threads[agent_id].is_alive():
        return {"error": "Agent is already running", "agent_id": agent_id}

    # Create stop flag
    stop_flag = threading.Event()
    _stop_flags[agent_id] = stop_flag

    # Start monitoring thread
    thread = threading.Thread(
        target=_agent_monitoring_loop,
        args=(agent_id, stop_flag),
        daemon=True
    )
    thread.start()
    _agent_threads[agent_id] = thread

    agent.enabled = True

    return {
        "timestamp": datetime.now().isoformat(),
        "agent_id": agent_id,
        "started": True,
        "interval_minutes": agent.interval_seconds // 60
    }


def stop_background_agent(agent_id: str) -> Dict[str, Any]:
    """Stop a background agent's monitoring loop."""
    if agent_id not in _background_agents:
        return {"error": f"Agent {agent_id} not found"}

    agent = _background_agents[agent_id]
    agent.enabled = False

    if agent_id in _stop_flags:
        _stop_flags[agent_id].set()

    return {
        "timestamp": datetime.now().isoformat(),
        "agent_id": agent_id,
        "stopped": True
    }


def _agent_monitoring_loop(agent_id: str, stop_flag: threading.Event):
    """Main monitoring loop for a background agent."""
    while not stop_flag.is_set():
        agent = _background_agents.get(agent_id)
        if not agent or not agent.enabled:
            break

        try:
            # Run the agent's check
            _run_agent_check(agent)
            agent.last_run = datetime.now().isoformat()
            agent.run_count += 1

            # Calculate next run
            next_run = datetime.now() + timedelta(seconds=agent.interval_seconds)
            agent.next_run = next_run.isoformat()

        except Exception as e:
            agent.error_count += 1
            logger.error(f"Background agent {agent_id} error: {e}")
            _create_alert(
                agent_id,
                agent.agent_type.value,
                AlertSeverity.ERROR,
                f"Agent Error: {agent.name}",
                str(e)
            )

        # Wait for interval or stop signal
        stop_flag.wait(timeout=agent.interval_seconds)


def _run_agent_check(agent: BackgroundAgent):
    """Run a single check for a background agent."""
    if agent.agent_type == BackgroundAgentType.CODE_SENTINEL:
        _run_code_sentinel_check(agent)
    elif agent.agent_type == BackgroundAgentType.DOC_KEEPER:
        _run_doc_keeper_check(agent)
    elif agent.agent_type == BackgroundAgentType.RESEARCH_WATCHER:
        _run_research_watcher_check(agent)
    elif agent.agent_type == BackgroundAgentType.MEETING_PREP:
        _run_meeting_prep_check(agent)


def _run_code_sentinel_check(agent: BackgroundAgent):
    """Run code sentinel checks."""
    config = agent.config

    # In a real implementation, this would:
    # 1. Check git status for recent changes
    # 2. Run security scanners
    # 3. Check code quality metrics
    # 4. Verify test coverage

    # For now, generate a sample analysis
    if agent.underlying_agent_id:
        task = """Analyze recent code changes and report on:
1. Any potential security concerns
2. Code quality issues
3. Missing or failing tests
4. Recommendations for improvement

Provide a brief, actionable summary."""

        result = execute_agent_task(agent.underlying_agent_id, task)

        if result.get("status") == "completed":
            # Check if any issues were found
            response = result.get("result", "").lower()
            if any(word in response for word in ["security", "vulnerability", "issue", "problem", "warning"]):
                _create_alert(
                    agent.id,
                    agent.agent_type.value,
                    AlertSeverity.WARNING,
                    "Code Review Alert",
                    result.get("result", "")[:500]
                )


def _run_doc_keeper_check(agent: BackgroundAgent):
    """Run documentation freshness checks."""
    # Check for outdated documentation
    if agent.underlying_agent_id:
        task = """Review documentation and code alignment:
1. Identify any documentation that may be outdated
2. Check for undocumented recent changes
3. Suggest documentation improvements

Be specific about files and sections that need attention."""

        result = execute_agent_task(agent.underlying_agent_id, task)

        if result.get("status") == "completed":
            response = result.get("result", "").lower()
            if any(word in response for word in ["outdated", "missing", "needs update", "inconsistent"]):
                _create_alert(
                    agent.id,
                    agent.agent_type.value,
                    AlertSeverity.INFO,
                    "Documentation Review",
                    result.get("result", "")[:500]
                )


def _run_research_watcher_check(agent: BackgroundAgent):
    """Run research monitoring checks."""
    topics = agent.config.get("topics", [])

    if not topics:
        return

    if agent.underlying_agent_id:
        topic_list = ", ".join(topics)
        task = f"""Research update for topics: {topic_list}

Summarize any recent developments, news, or important updates.
Focus on actionable insights and notable changes."""

        result = execute_agent_task(agent.underlying_agent_id, task)

        if result.get("status") == "completed" and result.get("result"):
            _create_alert(
                agent.id,
                agent.agent_type.value,
                AlertSeverity.INFO,
                f"Research Update: {topic_list[:50]}",
                result.get("result", "")[:500]
            )


def _run_meeting_prep_check(agent: BackgroundAgent):
    """Run meeting preparation checks."""
    # In a real implementation, this would check calendar
    # For now, it's a placeholder
    pass


def _create_alert(
    agent_id: str,
    agent_type: str,
    severity: AlertSeverity,
    title: str,
    message: str,
    metadata: Optional[Dict[str, Any]] = None
):
    """Create a new alert."""
    alert = Alert(
        id=f"alert_{uuid.uuid4().hex[:8]}",
        agent_id=agent_id,
        agent_type=agent_type,
        severity=severity,
        title=title,
        message=message,
        created_at=datetime.now().isoformat(),
        metadata=metadata or {}
    )
    _alerts.append(alert)

    # Keep only last 100 alerts
    if len(_alerts) > 100:
        _alerts.pop(0)


def get_alerts(
    agent_id: Optional[str] = None,
    severity: Optional[str] = None,
    unacknowledged_only: bool = False,
    limit: int = 50
) -> Dict[str, Any]:
    """Get alerts from background agents."""
    filtered = _alerts.copy()

    if agent_id:
        filtered = [a for a in filtered if a.agent_id == agent_id]

    if severity:
        try:
            sev = AlertSeverity(severity)
            filtered = [a for a in filtered if a.severity == sev]
        except ValueError:
            pass

    if unacknowledged_only:
        filtered = [a for a in filtered if not a.acknowledged]

    # Sort by created_at descending (newest first)
    filtered.sort(key=lambda x: x.created_at, reverse=True)

    # Limit results
    filtered = filtered[:limit]

    return {
        "timestamp": datetime.now().isoformat(),
        "total_alerts": len(_alerts),
        "filtered_count": len(filtered),
        "alerts": [
            {
                "id": a.id,
                "agent_id": a.agent_id,
                "agent_type": a.agent_type,
                "severity": a.severity.value,
                "title": a.title,
                "message": a.message,
                "created_at": a.created_at,
                "acknowledged": a.acknowledged
            }
            for a in filtered
        ]
    }


def acknowledge_alert(alert_id: str) -> Dict[str, Any]:
    """Acknowledge an alert."""
    for alert in _alerts:
        if alert.id == alert_id:
            alert.acknowledged = True
            return {
                "timestamp": datetime.now().isoformat(),
                "alert_id": alert_id,
                "acknowledged": True
            }

    return {"error": f"Alert {alert_id} not found"}


def list_background_agents() -> Dict[str, Any]:
    """List all background agents."""
    agents_list = []
    for agent_id, agent in _background_agents.items():
        is_running = agent_id in _agent_threads and _agent_threads[agent_id].is_alive()
        agents_list.append({
            "agent_id": agent_id,
            "agent_type": agent.agent_type.value,
            "name": agent.name,
            "enabled": agent.enabled,
            "running": is_running,
            "interval_minutes": agent.interval_seconds // 60,
            "run_count": agent.run_count,
            "error_count": agent.error_count,
            "last_run": agent.last_run,
            "next_run": agent.next_run
        })

    return {
        "timestamp": datetime.now().isoformat(),
        "total_agents": len(agents_list),
        "running_count": sum(1 for a in agents_list if a["running"]),
        "agents": agents_list
    }


def delete_background_agent(agent_id: str) -> Dict[str, Any]:
    """Stop and delete a background agent."""
    if agent_id not in _background_agents:
        return {"error": f"Agent {agent_id} not found"}

    # Stop if running
    stop_background_agent(agent_id)

    # Remove from storage
    agent = _background_agents.pop(agent_id)

    return {
        "timestamp": datetime.now().isoformat(),
        "agent_id": agent_id,
        "deleted": True,
        "name": agent.name
    }


def trigger_agent_run(agent_id: str) -> Dict[str, Any]:
    """Manually trigger an agent to run now."""
    if agent_id not in _background_agents:
        return {"error": f"Agent {agent_id} not found"}

    agent = _background_agents[agent_id]

    try:
        _run_agent_check(agent)
        agent.last_run = datetime.now().isoformat()
        agent.run_count += 1

        return {
            "timestamp": datetime.now().isoformat(),
            "agent_id": agent_id,
            "triggered": True,
            "run_count": agent.run_count
        }
    except Exception as e:
        return {
            "timestamp": datetime.now().isoformat(),
            "agent_id": agent_id,
            "triggered": False,
            "error": str(e)
        }


__all__ = [
    "BackgroundAgentType",
    "AlertSeverity",
    "create_background_agent",
    "start_background_agent",
    "stop_background_agent",
    "get_alerts",
    "acknowledge_alert",
    "list_background_agents",
    "delete_background_agent",
    "trigger_agent_run",
    "DEFAULT_CONFIGS"
]
